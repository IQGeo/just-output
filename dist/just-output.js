(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["jo"] = factory();
	else
		root["jo"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/node-libs-browser/mock/empty.js":
/*!******************************************************!*\
  !*** ./node_modules/node-libs-browser/mock/empty.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack://jo/./node_modules/node-libs-browser/mock/empty.js?");

/***/ }),

/***/ "./node_modules/os-browserify/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/os-browserify/browser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.endianness = function () {\n    return 'LE';\n};\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname;\n    } else return '';\n};\n\nexports.loadavg = function () {\n    return [];\n};\n\nexports.uptime = function () {\n    return 0;\n};\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () {\n    return [];\n};\n\nexports.type = function () {\n    return 'Browser';\n};\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces = exports.getNetworkInterfaces = function () {\n    return {};\n};\n\nexports.arch = function () {\n    return 'javascript';\n};\n\nexports.platform = function () {\n    return 'browser';\n};\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\nexports.homedir = function () {\n    return '/';\n};\n\n//# sourceURL=webpack://jo/./node_modules/os-browserify/browser.js?");

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function (filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function () {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = i >= 0 ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function (path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function (p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function (path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function () {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function (p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n// path.relative(from, to)\n// posix version\nexports.relative = function (from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\nexports.basename = function (path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  return splitPath(path)[3];\n};\n\nfunction filter(xs, f) {\n  if (xs.filter) return xs.filter(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    if (f(xs[i], i, xs)) res.push(xs[i]);\n  }\n  return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {\n  return str.substr(start, len);\n} : function (str, start, len) {\n  if (start < 0) start = str.length + start;\n  return str.substr(start, len);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://jo/./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n    return [];\n};\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};\n\n//# sourceURL=webpack://jo/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n//# sourceURL=webpack://jo/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/browserEnv.js":
/*!***************************!*\
  !*** ./src/browserEnv.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("let resultsPath = '_tests/results/';\nlet currentTest;\n\nfunction startRun(lResultsPath) {\n    if (lResultsPath) resultsPath = lResultsPath;\n    //ENH: simplify integration with react app\n    justOutputUIRender(true);\n}\n\nfunction startTest(test) {\n    currentTest = test;\n}\n\nfunction writeTmpResult(currentTestOutput) {\n    //do nothing\n    //ENH: write file via a chrome plugin?\n}\n\nfunction getAcceptedResult() {\n    const acceptedFilePath = getAcceptedResultPath();\n    const url = acceptedFilePath + '?' + Math.random(); //add a random param to the url so that the browser doesn't use cached results\n    return _ajax(url);\n}\n\nfunction getAcceptedResultPath() {\n    return resultsPath + currentTest.filename + '.txt';\n}\n\nfunction handleResult(result) {\n    window.handleTestResult(result, currentTest);\n}\n\nfunction list(test) {\n    console.log('test:', test.filename);\n}\n\nfunction _ajax(url) {\n    return new Promise(function (resolve, reject) {\n        var request = new XMLHttpRequest();\n\n        function onload() {\n            if (request.status >= 200 && request.status < 400) {\n                var result = request.response || request.responseText || request.responseXML;\n                resolve(result);\n            } else {\n                var error = new Error(\"Status code was \" + request.status);\n                error.code = request.status;\n                error.responseText = request.responseText;\n                reject(error);\n            }\n        }\n\n        function onerror() {\n            reject(new Error(\"Can't XHR \" + JSON.stringify(url)));\n        }\n\n        try {\n            request.open(\"GET\", url, true);\n            request.onreadystatechange = function () {\n                if (request.readyState === 4) {\n                    onload();\n                }\n            };\n            request.onload = request.load = onload;\n            request.onerror = request.error = onerror;\n            request.send();\n        } catch (exception) {\n            reject(exception);\n        }\n    });\n}\n\nmodule.exports = {\n    startRun,\n    startTest,\n    writeTmpResult,\n    getAcceptedResultPath,\n    getAcceptedResult,\n    handleResult,\n    list\n};\n\n//# sourceURL=webpack://jo/./src/browserEnv.js?");

/***/ }),

/***/ "./src/diff.js":
/*!*********************!*\
  !*** ./src/diff.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//Adapted from https://github.com/Slava/diff.js\n\n\n// Refer to http://www.xmailserver.org/diff2.pdf\n\n// Longest Common Subsequence\n// @param A - sequence of atoms - Array\n// @param B - sequence of atoms - Array\n// @param equals - optional comparator of atoms - returns true or false,\n//                 if not specified, triple equals operator is used\n// @returns Array - sequence of atoms, one of LCSs, edit script from A to B\nvar LCS = function (A, B, /* optional */equals) {\n  // We just compare atoms with default equals operator by default\n  if (equals === undefined) equals = function (a, b) {\n    return a === b;\n  };\n\n  // NOTE: all intervals from now on are both sides inclusive\n  // Get the points in Edit Graph, one of the LCS paths goes through.\n  // The points are located on the same diagonal and represent the middle\n  // snake ([D/2] out of D+1) in the optimal edit path in edit graph.\n  // @param startA, endA - substring of A we are working on\n  // @param startB, endB - substring of B we are working on\n  // @returns Array - [\n  //                   [x, y], - beginning of the middle snake\n  //                   [u, v], - end of the middle snake\n  //                    D,     - optimal edit distance\n  //                    LCS ]  - length of LCS\n  var findMidSnake = function (startA, endA, startB, endB) {\n    var N = endA - startA + 1;\n    var M = endB - startB + 1;\n    var Max = N + M;\n    var Delta = N - M;\n    var halfMaxCeil = (Max + 1) / 2 | 0;\n\n    var foundOverlap = false;\n    var overlap = null;\n\n    // Maps -Max .. 0 .. +Max, diagonal index to endpoints for furthest reaching\n    // D-path on current iteration.\n    var V = {};\n    // Same but for reversed paths.\n    var U = {};\n\n    // Special case for the base case, D = 0, k = 0, x = y = 0\n    V[1] = 0;\n    // Special case for the base case reversed, D = 0, k = 0, x = N, y = M\n    U[Delta - 1] = N;\n\n    // Iterate over each possible length of edit script\n    for (var D = 0; D <= halfMaxCeil; D++) {\n      // Iterate over each diagonal\n      for (var k = -D; k <= D && !overlap; k += 2) {\n        // Positions in sequences A and B of furthest going D-path on diagonal k.\n        var x, y;\n\n        // Choose from each diagonal we extend\n        if (k === -D || k !== D && V[k - 1] < V[k + 1])\n          // Extending path one point down, that's why x doesn't change, y\n          // increases implicitly\n          x = V[k + 1];else\n          // Extending path one point to the right, x increases\n          x = V[k - 1] + 1;\n\n        // We can calculate the y out of x and diagonal index.\n        y = x - k;\n\n        if (isNaN(y) || x > N || y > M) continue;\n\n        var xx = x;\n        // Try to extend the D-path with diagonal paths. Possible only if atoms\n        // A_x match B_y\n        while (x < N && y < M // if there are atoms to compare\n        && equals(A[startA + x], B[startB + y])) {\n          x++;y++;\n        }\n\n        // We can safely update diagonal k, since on every iteration we consider\n        // only even or only odd diagonals and the result of one depends only on\n        // diagonals of different iteration.\n        V[k] = x;\n\n        // Check feasibility, Delta is checked for being odd.\n        if ((Delta & 1) === 1 && inRange(k, Delta - (D - 1), Delta + (D - 1)))\n          // Forward D-path can overlap with reversed D-1-path\n          if (V[k] >= U[k])\n            // Found an overlap, the middle snake, convert X-components to dots\n            overlap = _.map([xx, x], toPoint, k); // XXX ES5\n      }\n\n      if (overlap) var SES = D * 2 - 1;\n\n      // Iterate over each diagonal for reversed case\n      for (var k = -D; k <= D && !overlap; k += 2) {\n        // The real diagonal we are looking for is k + Delta\n        var K = k + Delta;\n        var x, y;\n        if (k === D || k !== -D && U[K - 1] < U[K + 1]) x = U[K - 1];else x = U[K + 1] - 1;\n\n        y = x - K;\n        if (isNaN(y) || x < 0 || y < 0) continue;\n        var xx = x;\n        while (x > 0 && y > 0 && equals(A[startA + x - 1], B[startB + y - 1])) {\n          x--;y--;\n        }\n        U[K] = x;\n\n        if (Delta % 2 === 0 && inRange(K, -D, D)) if (U[K] <= V[K]) overlap = _.map([x, xx], toPoint, K); // XXX ES5\n      }\n\n      if (overlap) {\n        SES = SES || D * 2;\n        // Remember we had offset of each sequence?\n        for (var i = 0; i < 2; i++) for (var j = 0; j < 2; j++) overlap[i][j] += [startA, startB][j] - i;\n        return overlap.concat([SES, (Max - SES) / 2]);\n      }\n    }\n  };\n\n  var lcsAtoms = [];\n  var lcs = function (startA, endA, startB, endB) {\n    var N = endA - startA + 1;\n    var M = endB - startB + 1;\n\n    if (N > 0 && M > 0) {\n      var middleSnake = findMidSnake(startA, endA, startB, endB);\n      // A[x;u] == B[y,v] and is part of LCS\n      var x = middleSnake[0][0],\n          y = middleSnake[0][1];\n      var u = middleSnake[1][0],\n          v = middleSnake[1][1];\n      var D = middleSnake[2];\n\n      if (D > 1) {\n        lcs(startA, x - 1, startB, y - 1);\n        if (x <= u) {\n          [].push.apply(lcsAtoms, A.slice(x, u + 1));\n        }\n        lcs(u + 1, endA, v + 1, endB);\n      } else if (M > N) [].push.apply(lcsAtoms, A.slice(startA, endA + 1));else [].push.apply(lcsAtoms, B.slice(startB, endB + 1));\n    }\n  };\n\n  lcs(0, A.length - 1, 0, B.length - 1);\n  return lcsAtoms;\n};\n\n// Helpers\nvar inRange = function (x, l, r) {\n  return l <= x && x <= r || r <= x && x <= l;\n};\n\n// Takes X-component as argument, diagonal as context,\n// returns array-pair of form x, y\nvar toPoint = function (x) {\n  return [x, x - this]; // XXX context is not the best way to pass diagonal\n};\n\n// Wrappers\nLCS.StringLCS = function (A, B) {\n  return LCS(A.split(''), B.split('')).join('');\n};\n\n// Exports\nif (true) module.exports = LCS;\n\n// Diff sequence\n// @param A - sequence of atoms - Array\n// @param B - sequence of atoms - Array\n// @param equals - optional comparator of atoms - returns true or false,\n//                 if not specified, triple equals operator is used\n// @returns Array - sequence of objects in a form of:\n//   - operation: one of \"none\", \"add\", \"delete\"\n//   - atom: the atom found in either A or B\n// Applying operations from diff sequence you should be able to transform A to B\nvar diff = function (A, B, equals) {\n  // We just compare atoms with default equals operator by default\n  if (equals === undefined) equals = function (a, b) {\n    return a === b;\n  };\n\n  var diff = [];\n  var i = 0,\n      j = 0;\n  var N = A.length,\n      M = B.length,\n      K = 0;\n\n  while (i < N && j < M && equals(A[i], B[j])) i++, j++;\n\n  while (i < N && j < M && equals(A[N - 1], B[M - 1])) N--, M--, K++;\n\n  _.map([].push.apply(diff, A.slice(0, i)), function (atom) {\n    return { operation: \"none\", atom: atom };\n  });\n\n  var lcs = LCS(A.slice(i, N), B.slice(j, M), equals);\n\n  for (var k = 0; k < lcs.length; k++) {\n    var atom = lcs[k];\n    var ni = customIndexOf.call(A, atom, i, equals);\n    var nj = customIndexOf.call(B, atom, j, equals);\n\n    // XXX ES5 map\n    // Delete unmatched atoms from A\n    [].push.apply(diff, _.map(A.slice(i, ni), function (atom) {\n      return { operation: \"delete\", atom: atom };\n    }));\n\n    // Add unmatched atoms from B\n    [].push.apply(diff, _.map(B.slice(j, nj), function (atom) {\n      return { operation: \"add\", atom: atom };\n    }));\n\n    // Add the atom found in both sequences\n    diff.push({ operation: \"none\", atom: atom });\n\n    i = ni + 1;\n    j = nj + 1;\n  }\n\n  // Don't forget about the rest\n\n  [].push.apply(diff, _.map(A.slice(i, N), function (atom) {\n    return { operation: \"delete\", atom: atom };\n  }));\n\n  [].push.apply(diff, _.map(B.slice(j, M), function (atom) {\n    return { operation: \"add\", atom: atom };\n  }));\n\n  [].push.apply(diff, _.map(A.slice(N, N + K), function (atom) {\n    return { operation: \"none\", atom: atom };\n  }));\n\n  return diff;\n};\n\n// Accepts custom comparator\nvar customIndexOf = function (item, start, equals) {\n  var arr = this;\n  for (var i = start; i < arr.length; i++) if (equals(item, arr[i])) return i;\n  return -1;\n};\n\n// Exports\nmodule.exports = diff;\n\n//# sourceURL=webpack://jo/./src/diff.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {\nconst testsEnv = typeof window == 'undefined' ? __webpack_require__(/*! ./nodeEnv */ \"./src/nodeEnv.js\") : __webpack_require__(/*! ./browserEnv */ \"./src/browserEnv.js\");\nconst diff = __webpack_require__(/*! ./diff */ \"./src/diff.js\");\n\nconst tests = [];\nlet currentSuite;\nlet currentTest;\n\n/**\r\n * Declares a test suite\r\n * @param  {string} name        Name of test suite\r\n * @param  {function} [tests]   Tests to run. If not specified, all tests declared until next call will be considered part of this suite\r\n */\nfunction suite(name, tests) {\n    currentSuite = name;\n    if (tests) {\n        tests();\n        currentSuite = undefined;\n    }\n}\n\n/**\r\n * Declares a test\r\n * @param  {string} name        Name of test\r\n * @param  {function} testFunc  Function to execute as part of test\r\n */\nfunction test(name, testFunc) {\n    const fullName = currentSuite ? currentSuite + ' ' + name : name;\n    tests.push({\n        name: fullName,\n        testFunc,\n        suite: currentSuite,\n        filename: fullName.replace(/[^a-z0-9]/gi, '_')\n    });\n}\n\nfunction output() {\n    var args = _.map(arguments, function (value) {\n        return typeof value == 'string' ? value : _stringify(value);\n    });\n    currentTest.output += args.join(' ');\n    currentTest.output += '\\n';\n}\n\nfunction section(name, test) {\n    if (typeof test == 'function') {\n        output('\\n***', name);\n        test();\n    } else {\n        output('\\n***', ...arguments);\n    }\n}\n\nfunction subTest(name, test) {\n    currentTest.subTests.push(function () {\n        output('\\n***', name);\n        return Promise.resolve(test()).catch(_handleUnexpectedRejection);\n    });\n}\n\nfunction runTests(filter, resultsPath) {\n    testsEnv.startRun(resultsPath);\n    return Promise.each(tests, function (aTest) {\n        if (filter && !_includeTest(filter, aTest)) return;\n\n        currentTest = aTest;\n        currentTest.output = '';\n        currentTest.subTests = [];\n        testsEnv.startTest(currentTest);\n        return runTest(currentTest.testFunc).then(function () {\n            return Promise.each(currentTest.subTests, runTest);\n        }).catch(_handleUnexpectedRejection).tap(testsEnv.writeTmpResult).then(testsEnv.getAcceptedResult).catch(reason => undefined).then(_compareResultToAccepted).then(testsEnv.handleResult);\n    });\n}\n\nfunction runTest(testFunc) {\n    return Promise.resolve(testFunc()).catch(_handleUnexpectedRejection);\n}\n\nfunction listTests(filter) {\n    getTests(filter).forEach(testsEnv.list);\n}\n\nfunction getTests(filter) {\n    if (!filter) return tests;\n    return tests.filter(_includeTest.bind(null, filter));\n}\n\nvar _includeTest = function (filter, test) {\n    var testName = test.name;\n    return testName.match(filter) != null;\n};\n\nfunction _handleUnexpectedRejection(reason) {\n    var error = reason instanceof Error ? reason : new Error(reason.msg || reason);\n\n    if (document && document.location && document.location.search && document.location.search.indexOf(\"spec=\") >= 0) {\n        //individual test run              \n        if (document.location.search.indexOf(\"catch=false\") >= 0) {\n            throw error;\n        } else {\n            console.log(error.stack);\n            _outputErrorStack(error);\n        }\n    } else {\n        //full run (node or browser)\n        _outputErrorStack(error);\n    }\n}\n\nfunction _outputErrorStack(error) {\n    if (error.stack && error.stack.indexOf(\"From previous event\") >= 0) {\n        //include full stack as it will include the line that originated the error\n        _.each(error.stack.split('\\n'), function (line) {\n            output(line);\n        });\n    } else {\n        //no need to clutter output since it won't include the request's origin\n        output(\"Error: \" + error.message);\n    }\n}\n\nfunction _stringify(obj, indentLvl) {\n    var type = Object.prototype.toString.call(obj);\n    indentLvl = indentLvl || 1;\n    var indent = new Array(indentLvl + 1).join('\\t'),\n        indentClose = new Array(indentLvl).join('\\t');\n    if (type === '[object Object]') {\n        var pairs = [];\n        for (var k in obj) {\n            if (!obj.hasOwnProperty(k)) continue;\n            pairs.push([k, _stringify(obj[k], indentLvl + 1)]);\n        }\n        pairs.sort(function (a, b) {\n            return a[0] < b[0] ? -1 : 1;\n        });\n        pairs = _.reduce(pairs, function (m, v, i) {\n            return (i ? m + ',\\n' : '') + indent + '\"' + v[0] + '\": ' + v[1];\n        }, '');\n        return '{\\n' + pairs + '\\n' + indentClose + '}';\n    } else if (type === '[object Array]') {\n        return '[\\n' + _.reduce(obj, function (m, v, i) {\n            return (i ? m + ',\\n' : '') + indent + _stringify(v, indentLvl + 1);\n        }, '') + '\\n' + indentClose + ']';\n    } else if (type === '[object Number]') {\n        if (obj.toString().length > 13 || Math.abs(obj) > 1.0e+12) {\n            return parseFloat(obj.toPrecision(12)).toString();\n        }\n        return obj.toString();\n    }\n\n    return JSON.stringify(obj, null, '\\t');\n}\n\nfunction _compareResultToAccepted(expected) {\n    const actual = currentTest.output;\n    let fullContext = false;\n\n    if (!expected) {\n        var message = 'No accepted output (' + testsEnv.getAcceptedResultPath() + ')';\n        if (fullContext) message += '. Output: \\n' + actual;\n        return { pass: false, message: message };\n    }\n\n    var comparison = diff(actual.split(/\\r?\\n/), expected.split(/\\r?\\n/));\n    var diffs = _.filter(comparison, function (aDiff) {\n        return aDiff.operation == \"add\" || aDiff.operation == \"delete\";\n    });\n    var result = {\n        pass: diffs.length === 0,\n        message: ''\n    };\n    if (result.pass) {\n        result.message = \"output is equal to accepted output\";\n    } else {\n        var lineDiffs = [];\n        _.each(fullContext ? comparison : diffs, function (aDiff) {\n            if (aDiff.operation == \"add\") {\n                lineDiffs.push('-  ' + aDiff.atom);\n            } else if (aDiff.operation == \"delete\") {\n                lineDiffs.push('+  ' + aDiff.atom);\n            } else if (aDiff.atom) {\n                lineDiffs.push('   ' + aDiff.atom);\n            } else {\n                lineDiffs.push('   ' + aDiff);\n            }\n        });\n        result.message = \"Expected output to match accepted output:\\n\" + lineDiffs.join('\\n');\n        result.diffs = diffs;\n        result.comparison = comparison;\n    }\n    return result;\n}\n\n//these functions will be exposed as globals\nconst framework = {\n    suite,\n    test,\n    tests,\n    output,\n    subTest,\n    section\n};\nObject.assign(global, framework);\nglobal.jo = framework;\n\nmodule.exports = Object.assign(framework, {\n    runTests,\n    listTests\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://jo/./src/main.js?");

/***/ }),

/***/ "./src/nodeEnv.js":
/*!************************!*\
  !*** ./src/nodeEnv.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const fs = __webpack_require__(/*! fs */ \"./node_modules/node-libs-browser/mock/empty.js\");\nconst os = __webpack_require__(/*! os */ \"./node_modules/os-browserify/browser.js\");\nconst path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\nconst tmpdir = os.tmpdir();\nlet resultsPath = '_tests/results/';\n\nlet currentTest;\n\nfunction startRun(lResultsPath) {\n\t\t\t\tif (lResultsPath) resultsPath = lResultsPath;\n\t\t\t\tconsole.log(\"Temp directory: \", tmpdir);\n}\n\nfunction startTest(test) {\n\t\t\t\tcurrentTest = test;\n}\n\nfunction writeTmpResult(currentTestOutput) {\n\t\t\t\tlet resultFilePath = path.join(tmpdir, currentTest.filename + '.txt');\n\t\t\t\tfs.writeFileSync(resultFilePath, currentTest.output);\n}\n\nfunction getAcceptedResult() {\n\t\t\t\tconst acceptedFilePath = getAcceptedResultPath();\n\t\t\t\tlet acceptedOutput;\n\n\t\t\t\ttry {\n\t\t\t\t\t\t\t\tacceptedOutput = fs.readFileSync(acceptedFilePath, 'utf-8');\n\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t// console.log(error);\n\t\t\t\t}\n\t\t\t\treturn Promise.resolve(acceptedOutput);\n}\n\nfunction getAcceptedResultPath() {\n\t\t\t\treturn resultsPath + currentTest.filename + '.txt';\n}\n\nfunction handleResult(result) {\n\t\t\t\tif (result.pass) {\n\t\t\t\t\t\t\t\tconsole.log(currentTest.name + ': PASSED');\n\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconsole.log(currentTest.name + ':\\t' + result.message.slice(0, 180));\n\t\t\t\t\t\t\t\tconsole.log(currentTest.name + ': FAILED');\n\t\t\t\t}\n}\n\nfunction list(test) {\n\t\t\t\tconsole.log('test:', test.filename);\n}\n\nmodule.exports = {\n\t\t\t\tstartRun,\n\t\t\t\tstartTest,\n\t\t\t\twriteTmpResult,\n\t\t\t\tgetAcceptedResultPath,\n\t\t\t\tgetAcceptedResult,\n\t\t\t\thandleResult,\n\t\t\t\tlist\n};\n\n//# sourceURL=webpack://jo/./src/nodeEnv.js?");

/***/ })

/******/ });
});